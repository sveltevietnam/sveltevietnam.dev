import fs from 'node:fs/promises';
import path from 'node:path';

import dedent from 'dedent';
import glob from 'tiny-glob';

const ts = dedent;

/**
 *	@typedef RoutingInput
 *	@property {string | Record<import('@internals/utils/language').Language, string>} pathSegment
 *	@property {string | Record<import('@internals/utils/language').Language, string>} name
 */

/**
 * @typedef RoutingOutput
 * @property {string} path
 * @property {string} name
 */

/**
 * @typedef RerouteConfig
 * @property {Record<string, string>} viToEn
 * @property {string[]} mismatchedPaths
 */

/**
 * @returns {import('vite').Plugin}
 */
export function sveltekitRouting() {
	const routesPath = 'src/routes';
	const routingFilename = '_page/routing.json';
	const index = 'home';

	return {
		name: 'sveltekit-routing',
		enforce: 'post',
		async configureServer(server) {
			const root = server.config.root;
			const routingGlob = path.join(routesPath, '**', routingFilename);
			const mapsOutdir = 'src/data/routing';
			const typesOutpath = 'src/routing.generated.d.ts';

			async function build() {
				console.log('Building routing maps...');
				const routingFilePaths = await glob(routingGlob, { cwd: root });

				/** @type {Map<string, RoutingInput>} */
				const routes = new Map();

				/** @type {string[]} */
				const keys = [];
				for (const path of routingFilePaths) {
					const key =
						path
							.slice(routesPath.length, -routingFilename.length)
							// remove layout group (...)
							.replace(/\/\(.*\)/g, '')
							// replace [[param=...]] with :param
							.replace(/\[+(.*)[\]=]/g, (_, p1) => ':' + p1)
							.slice(1, -1) || index;

					keys.push(key);

					const routing = /** @type {RoutingInput} */ (
						JSON.parse(await fs.readFile(path, 'utf-8'))
					);
					routes.set(key, routing);
				}

				/** @type {Record<string, RoutingOutput>}*/
				const viMap = {};
				/** @type {Record<string, RoutingOutput>}*/
				const enMap = {};
				/** @type {RerouteConfig}*/
				const rerouteConfig = {
					viToEn: {},
					mismatchedPaths: [],
				};

				for (const [key, route] of routes.entries()) {
					const segments = key.split('/').slice(0, -1);
					let delocalizedViPath = '';
					let delocalizedEnPath = '';

					if (key !== 'home') {
						for (const segment of segments) {
							const route = routes.get(segment);
							if (!route) throw new Error(`No routing.json is defined for ${segment}`);

							delocalizedViPath += '/' + (typeof route.pathSegment === 'string' ? route.pathSegment : route.pathSegment.vi);
							delocalizedEnPath += '/' + (typeof route.pathSegment === 'string' ? route.pathSegment : route.pathSegment.en);
						}

						delocalizedViPath += '/' + (typeof route.pathSegment === 'string' ? route.pathSegment : route.pathSegment.vi);
						delocalizedEnPath += '/' + (typeof route.pathSegment === 'string' ? route.pathSegment : route.pathSegment.en);
					}

					viMap[key] = {
						path: '/vi' + delocalizedViPath,
						name: typeof route.name === 'string' ? route.name : route.name.vi,
					};
					enMap[key] = {
						path: '/en' + delocalizedEnPath,
						name: typeof route.name === 'string' ? route.name : route.name.en,
					};

					if (delocalizedViPath !== delocalizedEnPath) {
						rerouteConfig.viToEn[delocalizedViPath] = delocalizedEnPath;
						rerouteConfig.mismatchedPaths.push('/vi' + delocalizedEnPath);
					}
				}

				const source = ts`
					/** DO NOT EDIT! This file is generated by vite-plugin-sveltekit-routing */
					declare namespace App {
						export type RouteKey = ${keys.map((key) => `'${key}'`).join(' | ')};
						export type Route = {
							path: string;
							name: string;
						};
					}
				`;

				await fs.mkdir(path.join(root, mapsOutdir), { recursive: true });
				await Promise.all([
					fs.writeFile(
						path.join(root, mapsOutdir, 'vi.generated.json'),
						JSON.stringify(viMap, null, 2),
					),
					fs.writeFile(
						path.join(root, mapsOutdir, 'en.generated.json'),
						JSON.stringify(enMap, null, 2),
					),
					fs.writeFile(
						path.join(root, mapsOutdir, 'reroute-config.generated.json'),
						JSON.stringify(rerouteConfig, null, 2)
					),
					fs.writeFile(path.join(root, typesOutpath), source),
				]);
			}

			server.watcher.add(routingGlob);
			server.watcher.on('add', build);
			server.watcher.on('change', build);

			await build();
		},
	};
}
